test_before_fix:
    public void testScan() throws InitializationException, IOException {
        final String tableName = "nifi";
        final TestRunner runner = TestRunners.newTestRunner(TestProcessor.class);

        // Mock an HBase Table so we can verify the put operations later
        final Table table = Mockito.mock(Table.class);
        when(table.getName()).thenReturn(TableName.valueOf(tableName));

        // create the controller service and link it to the test processor
        final MockHBaseClientService service = configureHBaseClientService(runner, table);
        runner.assertValid(service);

        // stage some results in the mock service...
        final long now = System.currentTimeMillis();

        final Map<String, String> cells = new HashMap<>();
        cells.put("greeting", "hello");
        cells.put("name", "nifi");

        service.addResult("row0", cells, now - 2);
        service.addResult("row1", cells, now - 1);
        service.addResult("row2", cells, now - 1);
        service.addResult("row3", cells, now);

        // perform a scan and verify the four rows were returned
        final CollectingResultHandler handler = new CollectingResultHandler();
        final HBaseClientService hBaseClientService = runner.getProcessContext().getProperty(TestProcessor.HBASE_CLIENT_SERVICE)
                .asControllerService(HBaseClientService.class);

        hBaseClientService.scan(tableName, new ArrayList<Column>(), null, now, handler);
        assertEquals(4, handler.results.size());

        // get row0 using the row id and verify it has 2 cells
        final ResultCell[] results = handler.results.get("row0");
        assertNotNull(results);
        assertEquals(2, results.length);

        verifyResultCell(results[0], COL_FAM, "greeting", "hello");
        verifyResultCell(results[1], COL_FAM, "name", "nifi");
    }

test_after_fix:

code:
 
  
 public void testScan() throws InitializationException, IOException { 
     final String tableName = "nifi"; 
     final TestRunner runner = TestRunners.newTestRunner(TestProcessor.class); 
  
     // Mock an HBase Table so we can verify the put operations later 
     final Table table = Mockito.mock(Table.class); 
     when(table.getName()).thenReturn(TableName.valueOf(tableName)); 
  
     // create the controller service and link it to the test processor 
     final MockHBaseClientService service = configureHBaseClientService(runner, table); 
     runner.assertValid(service); 
  
     // stage some results in the mock service... 
     final long now = System.currentTimeMillis(); 
  
     final Map<String, String> cells = new LinkedHashMap<>(); 
     cells.put("greeting", "hello"); 
     cells.put("name", "nifi"); 
  
     service.addResult("row0", cells, now - 2); 
     service.addResult("row1", cells, now - 1); 
     service.addResult("row2", cells, now - 1); 
     service.addResult("row3", cells, now); 
  
     // perform a scan and verify the four rows were returned 
     final CollectingResultHandler handler = new CollectingResultHandler(); 
     final HBaseClientService hBaseClientService = runner.getProcessContext().getProperty(TestProcessor.HBASE_CLIENT_SERVICE) 
             .asControllerService(HBaseClientService.class); 
  
     hBaseClientService.scan(tableName, new ArrayList<Column>(), null, now, handler); 
     assertEquals(4, handler.results.size()); 
  
     // get row0 using the row id and verify it has 2 cells 
     final ResultCell[] results = handler.results.get("row0"); 
     assertNotNull(results); 
     assertEquals(2, results.length); 
  
     for (ResultCell result : results) { 
         if (new String(result.getQualifierArray()).equals("greeting")) { 
             verifyResultCell(result, COL_FAM, "greeting", "hello"); 
         } else if (new String(result.getQualifierArray()).equals("name")) { 
             verifyResultCell(result, COL_FAM, "name", "nifi"); 
         } 
     } 
 } 
  
  
 
import:
[]
pom:

