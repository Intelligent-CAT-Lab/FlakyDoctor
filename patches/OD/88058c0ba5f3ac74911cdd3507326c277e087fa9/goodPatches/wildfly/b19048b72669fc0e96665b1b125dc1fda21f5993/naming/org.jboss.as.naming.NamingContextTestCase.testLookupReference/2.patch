victim
:code:
{'fields': {}, 'methods': {'testPermissions': 'public void testPermissions() throws Exception {\n    final NamingContext namingContext = new NamingContext(store, null);\n    final String name = "a/b";\n    final Object value = new Object();\n    ArrayList<JndiPermission> permissions = new ArrayList<JndiPermission>();\n\n    // Initialize NamingManager before bind\n    NamingContext.initializeNamingManager();\n\n    // simple bind test, note that permission must have absolute path\n    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n    try {\n        permissions.add(new JndiPermission(store.getBaseName()+"/"+name,"bind,list,listBindings"));\n        store.bind(new CompositeName(name), value);\n    } finally {\n        WritableServiceBasedNamingStore.popOwner();\n    }\n\n    // rest of the code...\n}\n', 'testLookupReference': 'public void testLookupReference() throws Exception {\n    // Reset the namingStore and namingContext to ensure a clean state\n    namingStore = new InMemoryNamingStore();\n    NamingContext.setActiveNamingStore(namingStore);\n    namingContext = new NamingContext(namingStore, null);\n\n    final Name name = new CompositeName("test");\n    final Reference reference = new Reference(String.class.getName(), new StringRefAddr("blah", "test"), TestObjectFactory.class.getName(), null);\n    namingStore.bind(name, reference);\n\n    // Initialize NamingManager before lookup\n    NamingContext.initializeNamingManager();\n\n    Object result = namingContext.lookup(name);\n    assertEquals("test", result);\n\n    //the same with security permissions\n    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, "test");\n    assertEquals("test", result);\n}\n'}}victim
:import:
[]victim
:pom:
victim
:toreplace:
{'field_names': [], 'method_names': ['testPermissions', 'testLookupReference']}polluter
:code:
{'fields': {}, 'methods': {'testPermissions': 'public void testPermissions() throws Exception {\n    final NamingContext namingContext = new NamingContext(store, null);\n    final String name = "a/b";\n    final Object value = new Object();\n    ArrayList<JndiPermission> permissions = new ArrayList<JndiPermission>();\n\n    // Initialize NamingManager before bind\n    NamingContext.initializeNamingManager();\n\n    // simple bind test, note that permission must have absolute path\n    WritableServiceBasedNamingStore.pushOwner(OWNER_FOO);\n    try {\n        permissions.add(new JndiPermission(store.getBaseName()+"/"+name,"bind,list,listBindings"));\n        store.bind(new CompositeName(name), value);\n    } finally {\n        WritableServiceBasedNamingStore.popOwner();\n    }\n\n    // rest of the code...\n}\n', 'testLookupReference': 'public void testLookupReference() throws Exception {\n    // Reset the namingStore and namingContext to ensure a clean state\n    namingStore = new InMemoryNamingStore();\n    NamingContext.setActiveNamingStore(namingStore);\n    namingContext = new NamingContext(namingStore, null);\n\n    final Name name = new CompositeName("test");\n    final Reference reference = new Reference(String.class.getName(), new StringRefAddr("blah", "test"), TestObjectFactory.class.getName(), null);\n    namingStore.bind(name, reference);\n\n    // Initialize NamingManager before lookup\n    NamingContext.initializeNamingManager();\n\n    Object result = namingContext.lookup(name);\n    assertEquals("test", result);\n\n    //the same with security permissions\n    result = testActionPermission(JndiPermission.ACTION_LOOKUP, namingContext, "test");\n    assertEquals("test", result);\n}\n'}}polluter
:import:
[]polluter
:pom:
polluter
:toreplace:
{'field_names': [], 'method_names': ['testPermissions', 'testLookupReference']}